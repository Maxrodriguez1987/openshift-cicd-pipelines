@Library("pipeline-library") 
import com.redhat.openshift.pipelines.Commons

def commons = new Commons(this)

pipeline {
    agent any
    options {
        skipDefaultCheckout()
        disableConcurrentBuilds()
    }
    environment {
        APP_TEMPLATE = "openshift/template.yaml"
        APP_CONFIG = "config/environments/prod/config.yaml"
        APP_DEPLOYMENT_PATCH = "config/environments/prod/deployment.yaml"
        APP_CONFIG_DIR = "config"
    }
    stages {
        stage("Initialize") {
            steps {
                script {
                    if (!env.IMAGE_NAME)
                        env.IMAGE_NAME = env.APP_NAME

                    // Gets the application project
                    env.PROJECT = commons.getApplicationProject()
                }
            }
        }
        stage("Select Tag") {
            when {
                not {
                    expression {
                        return env.TAG
                    }
                }
            }
            steps {
                script {
                    openshift.withCluster() {
                        openshift.withProject(env.SRC_PROJECT) {
                            // Generates a list of tags to deploy
                            env.TAG = commons.getVersion(env.APP_NAME)
                            // Checkout same tag from Git
                            env.GIT_BRANCH = env.TAG
                        }
                    }
                }
            }
        }
        stage("Checkout Code") {
            steps {
                script {
                    openshift.withCluster(env.DST_CLUSTER_URL, env.DST_CLUSTER_TOKEN) {
                        openshift.withProject(env.PROJECT) {
                            commons.gitCheckout(env.GIT_REPO, env.GIT_BRANCH, env.GIT_SECRET)
                        }
                    }
                }
            }
        }
        stage ("Apply Template") {
            when {
                expression {
                    return commons.hasTemplate(env.APP_TEMPLATE)
                }
            }
            steps {
                script {
                    openshift.withCluster(env.DST_CLUSTER_URL, env.DST_CLUSTER_TOKEN) {
                        openshift.withProject(env.DST_PROJECT) {
                            // Uses the template to create the application
                            openshift.apply(commons.processTemplate(env.APP_TEMPLATE, env.APP_NAME, env.IMAGE_NAME))
                        }
                    }
                }
            }
        }
        stage ("Apply Configuration") {
            when {
                expression {
                    return commons.hasTemplate(env.APP_TEMPLATE)
                }
            }
            steps {
                script {
                    openshift.withCluster() {
                        openshift.withProject(env.DST_PROJECT) {
                            dir(env.APP_CONFIG_DIR) {
                                commons.gitCheckoutConfig(env.GIT_REPO, env.GIT_BRANCH, env.GIT_SECRET, env.APP_CONFIG_DIR)
                            }

                            commons.applyConfigChanges(APP_CONFIG, APP_DEPLOYMENT_PATCH)
                        }
                    }
                }
            }
        }
        stage("Promote Tag") {
            agent {
                label "skopeo"
            }
            steps {
                script {
                    // Credentials
                    def srcCreds = "unused:${env.SRC_REGISTRY_TOKEN}";
                    def dstCreds = "unused:${env.DST_REGISTRY_TOKEN}";

                    // Paths 
                    def src = "docker://${env.SRC_REGISTRY_URL}/${env.SRC_PROJECT}/${env.IMAGE_NAME}:${env.TAG}";
                    def dst = "docker://${env.DST_REGISTRY_URL}/${env.DST_PROJECT}/${env.IMAGE_NAME}:${env.TAG}";

                    // Executes the Skopeo command
                    sh "skopeo copy --src-tls-verify=false --dest-tls-verify=false --src-creds=${srcCreds} --dest-creds=${dstCreds} ${src} ${dst}";
                }
            }
        }
        stage("Approve Deploy") {
            when {
                expression {
                    return env.APPROVAL_GROUP
                }
            }
            steps {
                script {
                    openshift.withCluster() {
                        commons.resolveApproval(env.APPROVAL_GROUP)
                    }
                }
            }
        }
        stage("Deploy Application") {
            steps {
                script {
                    openshift.withCluster(env.DST_CLUSTER_URL, env.DST_CLUSTER_TOKEN) {
                        openshift.withProject(env.DST_PROJECT) {
                            commons.deployApplication(env.APP_NAME, env.IMAGE_NAME, env.TAG)
                        } 
                    }
                }
            }
        }
    }
}