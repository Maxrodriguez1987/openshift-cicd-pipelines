pipeline {
    agent any
    options {
        skipDefaultCheckout()
        disableConcurrentBuilds()
    }
    stages {
        stage("Initialize") {
            steps {
                script {
                    if (!env.IMAGE_NAME)
                        env.IMAGE_NAME = env.APP_NAME
                }
            }
        }
        // If Git repository environment variable is not set, asks for it
        stage("Set Repository") {
            when {
                not {
                    expression {
                        return env.GIT_REPO
                    }
                }
            }
            steps {
                script {
                    env.GIT_REPO = input(id: 'repository',
                                         message: 'Select Git repository where the application template resides',
                                         parameters: [string(defaultValue: '', name: 'Repository')]);
                }
            }
        }
        // If Git branch environment variable is not set, asks for it
        stage("Set Branch") {
            when {
                not {
                    expression {
                        return env.GIT_BRANCH
                    }
                }         
            }
            steps {
                script {
                    env.GIT_BRANCH = input(id: 'branch',
                                           message: 'Select Git branch',
                                           parameters: [string(defaultValue: 'master', name: 'Branch')]);
                }
            }
        }
        // If Git credentials environment variable is not set, asks for it
        stage("Set Credentials") {
            when {
                not {
                    expression {
                        return env.GIT_SECRET
                    }
                }         
            }
            steps {
                script {
                    env.GIT_BRANCH = input(id: "secret",
                                           message: "Set Git credentials (OpenShift secret)",
                                           parameters: [string(defaultValue: "", name: "Branch", description: "Must be an OpenShift secret")]);
                }
            }
        }
        stage("Checkout Code") {
            steps {
                script {
                    if (env.GIT_SECRET && env.GIT_SECRET != "" && env.GIT_SECRET != "none") {
                        openshift.withCluster() {
                            openshift.withProject {
                                git(branch: env.GIT_BRANCH, url: env.GIT_REPO, credentialsId: "${openshift.project()}-${env.GIT_SECRET}");
                            }
                        }
                    }
                    else
                        git(branch: env.GIT_BRANCH, url: env.GIT_REPO);
                }
            }
        }
        // If project environment variable is not set, asks for it
        stage("Set Project (SRC)") {
            when {
                not {
                    expression {
                        return env.SRC_PROJECT_NAME
                    }
                }
            }
            steps {
                script {
                     env.SRC_PROJECT_NAME = input(id: 'project',
                                            message: 'Select the project where the tag to deploy resides',
                                            parameters: [string(defaultValue: '', name: 'Source Project')]);
                }
            }
        }
        stage("Set Project (DST)") {
            when {
                not {
                    expression {
                        return env.DST_PROJECT_NAME
                    }
                }
            }
            steps {
                script {
                     env.DST_PROJECT_NAME = input(id: 'project',
                                            message: 'Select the project to deploy',
                                            parameters: [string(defaultValue: '', name: 'Destination Project')]);
                }
            }
        }
        // If application environment variable is not set, asks for it
        stage("Set Application") {
            when {
                not {
                    expression {
                        return env.APP_NAME
                    }
                }
            }
            steps {
                script {
                     env.APP_NAME = input(id: 'application',
                                    message: 'Select the application to deploy',
                                    parameters: [string(defaultValue: '', name: 'Application')]);
                }
            }
        }
        stage("Promote Objects") {
            steps {
                script {
                    openshift.withCluster() {
                        openshift.withProject() {
                            // Uses the template to create the application
                            objects = openshift.process(readFile(file: env.APP_TEMPLATE_FILE), "-p", "PARAM_APP_NAME=${env.APP_NAME}");

                            openshift.withCluster(env.DST_CLUSTER_URL, env.DST_CLUSTER_TOKEN) {
                                openshift.withProject(env.DST_PROJECT_NAME) {
                                    for (o in objects) {
                                        // Prevents to promote the BuildConfig and ImageSream, the build is only done in development stages
                                        if (o.kind != "BuildConfig" && o.kind != "ImageStream") 
                                            openshift.apply(o);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        stage("Select Tag") {
            when {
                not {
                    expression {
                        return env.TAG
                    }
                }
            }
            steps {
                script {
                    openshift.withCluster() {
                        echo openshift.cluster();
                        openshift.withProject(env.SRC_PROJECT_NAME) {
                            // Generates a list of tags to deploy
                            def is = openshift.selector("is", env.APP_NAME).object();
                            def tags = "";
                            
                            for (version in is.status.tags)
                                tags = version.tag + "\n" + tags;
                            
                            env.TAG = input(message: "Select version",
                                            parameters: [choice(choices: tags, description: 'Select a tag to deploy', name: 'Versions')]);
                        }
                    }
                }
            }
        }
        stage("Promote Tag") {
            agent {
                label "skopeo"
            }
            steps {
                script {
                    // Credentials
                    def srcCreds = "unused:${env.SRC_REGISTRY_TOKEN}";
                    def dstCreds = "unused:${env.DST_REGISTRY_TOKEN}";

                    // Paths 
                    def src = "${env.SRC_REGISTRY_URL}/${env.SRC_PROJECT_NAME}/${env.APP_NAME}:${env.TAG}";
                    def dst = "${env.DST_REGISTRY_URL}/${env.DST_PROJECT_NAME}/${env.APP_NAME}:${env.TAG}";

                    // Executes skopeo command
                    sh "skopeo copy --src-tls-verify=false --dest-tls-verify=false --src-creds=${srcCreds} --dest-creds=${dstCreds} ${src} ${dst}";
                }
            }
        }
        stage("Approve Deploy") {
            steps {
                script {
                    def submitter = input message: 'Confirm deployment', submitterParameter: 'submitter';
                    def user = submitter.substring(0, submitter.lastIndexOf("-"));
                    def canApprove = false;

                    openshift.withCluster() {
                        echo openshift.cluster();
                        openshift.verbose();
                        def groups = openshift.selector("groups").objects();

                        for (g in groups) {
                            if (g.metadata.name.equals(env.APPROVAL_GROUP) && g.users.contains(user)) {
                                canApprove = true;
                                echo "User ${user} from group ${g.metadata.name} approved the deployment"
                            } 
                        }

                        if (canApprove == false)
                            error "User ${user} is not allowed to approve the deployment"
                    }
                }
            }
        }
        stage("Deploy Application") {
            steps {
                script {
                    openshift.withCluster(env.DST_CLUSTER_URL, env.DST_CLUSTER_TOKEN) {
                        openshift.withProject(env.DST_PROJECT_NAME) {
                            // Adds a trigger for deploying the tag, this will cause an automatic rollout
                            openshift.set("triggers", "dc/${env.APP_NAME}", "--from-image=${env.IMAGE_NAME}:${env.TAG}", "-c ${env.APP_NAME}");
                        } 
                    }
                }
            }
        }
    }
}